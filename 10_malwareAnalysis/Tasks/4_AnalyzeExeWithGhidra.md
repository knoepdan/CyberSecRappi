# Analyze exe with Ghidra1E

Generall info: 
- 32 bit application for windows
- Calling conventions used
    -  "cdecl" (which seems to be used.. but maybe not for all calls)
        - All params on stack
        - Return value usually in EAX (exception: floating point.. see wiki)
        - EAX, ECX und EDX can be used freely in function (other register need to be saved on stack)
    - stdcall (standard for WIN32-API functions)
        - return value in EAX
        - (stack handling slightly different)
    - See : https://de.wikipedia.org/wiki/Aufrufkonvention


## Unpack using UPX (on Kali Linux)
https://manalyzer.org  indicated file was packed so I unpacked it using upx. 

`upx --best -d sample2.exe` will unpack the file sample2.exe and replace it

(not using unipacker because installation was cumbersome due to some pyhton version issues)

## Analyze

**Following jumps** (and what is the state in registers / memory address)


-------------
**FUN_MaybeMain_004011b0**

```
004011c2   TEST ESP, ESP  ; will never be 0 
004011c4   JNZ  LAB_004011c6  ; will always jump
```
-> makes no sense to have a JNZ instruction but the jump location is the next isntruction there is no need to patch this



```
004011b9   CALL LAB_004011be  ; will never be 0 
004011be   ADD byte ptr [ESP], 0x17 ; will set the stackpoint to an address which is 004011be + 0x17 (because CALL instruction pushes ) 
...  .. will execute a CALL and then correct the stackpointer ESP for the arguments being used (ADD ESP, 0x4)
RET ;   will return to 004011d5   (004011be + 0x17)

```

**From address 004011d5 (undefined func) -> jump to LAB_0040126f if no debugger attached**
 
```
004011d5   CALL IsDebuggerPresent  ; false (0) if no debugger is present, true (any value != 0) if there is a debugger -> written to EAX
004011db   TEST EAX, EAX   ; sets ZF flag to 1 if value is 0 (NO Debugger attached)
004011dd   JZ, LAB_004011e9   ; jumpf if ZF=1  (will only jump if NO debugger is present !!!)

```
**From address LAB_0040126f (we get here when we are not debugging)**
```
0040126f   CALL ... ; register FUN_00401070 as handler for exceptions     
004011f4   XOR  EAX, EAX ; -> will fill EAX with 0
004011f6   DIV EAX;    will cause an exception (division by zero) and the previously registered function is executed
```

**From function FUN_ExHandler_00401070  (we get here because of division by zero, when we are not debugging)**
-> we will continue execution where exception has occured (because of return value 0xffffffff). see: https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setunhandledexceptionfilter or http://win32easy.blogspot.com/2011/03/exception-handling-inform-your-users.html )
```
00401091   OR  EAX, 0xffffffff  ;   sets return value. 
...
00401095   RET 0x4  ; return stdcall convention (0xffffffff means we continue execution where original exception has occured)
```

**returning from exception handler (next instruction after div by zero)**

Instruction weaving ??? 
I think it should jump but probably doesn.. dont get anywhere with this  :-(
```
004011f8    PUSH 0x401202  
004011fd    JNC LAB_004011fd+1    ; will jump 
            PUSH ES   (what is in ES???)

```
00 40 12 02 

00 40 12 00 

00 40 00 00  ES is 16 bit


## Leftovers

x86 64 bit assembler 
- https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf 

- https://www.nasm.us/ NASM
- https://filippo.io/linux-syscall-table/ (System calls on linux)
- https://en.wikipedia.org/wiki/X86_instruction_listings instructions
- https://www.felixcloutier.com/x86/ (also instructions)
- https://faydoc.tripod.com/cpu/jc.htm  (instructions...good for jump instructions)


Good to know
- `LEA EDI, [ESI+0xffffa000]=>DAT_00401000`  "=>" means that Ghidra was able to infer that [ESI+0xffffa000] is the value of memory address DAT_004010000


Examples instructions
- `MOV dst src` -> moves data from source to destiation
    - src can be pointers to memory, registers, constants
    - dst can be pointers to memory + registers (some registers are excluded)
- `LEA rsi [someLabel]` -> moves/loads the memory address into rsi   

- Size (for constant declaratiosn)
    - "db": byte ->  one-byte integer
    - "dw"  WORD ->  two-byte integer (16bit)
    - "dd"  DOUBLEWORD (DWORD) -> four-byte integer (32bit)
    - "dq" -> QUADWORD (QWORD) -> eight-byte integer (64bit)
        - The size of a register (e.g. "RDI")
- Values in memory are in little endian format. 
    - Example hex number: 4F52 
        - little endian:  52 4F
            - 52 at addresse 1000, 4f at address 1001
            - used by x86 CPU's
        - big endian (intuitive):  4F 52


*Remark: Theoretically the size of a word could depend on the unit the processor could process in one step or in some cases (programming languages) on the context. * 

