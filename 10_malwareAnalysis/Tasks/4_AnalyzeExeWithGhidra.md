# Analyze exe with Ghidra1E

**Quick answers**
- How has it been protected?
    - packed via upx
    - Anti-dissasembling techniques
        - Empty return
        - Some unnecessary code (code bloating)
    - Anti-debugging techniques
        - detecting debugger (via windows api)
        - Structured exception handler
        - maybe CC instructions were added too (found quite a few of them but quite be that they were never on the execution path and just data )
    - I guess I did not find all techniques :-( )
- What does it do?
    - I will return a message that parameters are invalid but then continue execution (misleading the user)
    - I have most probably not found out what the program actually as I believe I have failed to disassemble all correctly :-()



**Generall info**
- 32 bit application for windows
- Calling conventions used
    -  "cdecl" (which seems to be used.. but maybe not for all calls)
        - All params on stack
        - Return value usually in EAX (exception: floating point.. see wiki)
        - EAX, ECX und EDX can be used freely in function (other register need to be saved on stack)
    - stdcall (standard for WIN32-API functions)
        - return value in EAX
        - (stack handling slightly different)
    - See : https://de.wikipedia.org/wiki/Aufrufkonvention

## Steps

### Unpack using UPX (on Kali Linux)
https://manalyzer.org  indicated file was packed so I unpacked it using upx. 

`upx --best -d sample2.exe` will unpack the file sample2.exe and replace it

(not using unipacker because installation was cumbersome due to some pyhton version issues)

### Analyze and disassemble

*Debugging not possible due to linking error (anti debugging measures could be patched*)

**Following jumps** (and what is the state in registers / memory address)


**FUN_Main_004011b0**

"Empty return" detected. We will be forwarded (return) to "004011d5" (004011be + 0x17) 
```
004011b9   CALL LAB_004011be  ; will never be 0 
004011be   ADD byte ptr [ESP], 0x17 ; will set the stackpoint to an address which is 004011be + 0x17 (because CALL instruction pushes ) 
...  .. will execute a CALL and then correct the stackpointer ESP for the arguments being used (ADD ESP, 0x4)
RET ;   will return to 004011d5   (004011be + 0x17)

```

**From address 004011d5 (undefined func, 004011be + 0x17) -> jump to LAB_004011e9_NoDebuggerAttaqched**
Anti-debugging measure detected. If debugger is attached, we exit otherwise we jump to a label
```
004011d5   CALL IsDebuggerPresent  ; false (0) if no debugger is present, true (any value != 0) if there is a debugger -> written to EAX
004011db   TEST EAX, EAX   ; sets ZF flag to 1 if value is 0 (NO Debugger attached)
004011dd   JZ, LAB_004011e9   ; jumpf if ZF=1  (will only jump if NO debugger is present !!!)
```

**From LAB_004011e9_NoDebuggerAttached (exception handler function)**

Anti-debugging measure detected. We register a exception handler function and then an exception is triggered by a devision by zero.
```
0040126f   CALL ... ; register FUN_00401070 as handler for exceptions     
004011f4   XOR  EAX, EAX ; -> will fill EAX with 0
004011f6   DIV EAX;    will cause an exception (division by zero) and the previously registered function is executed
```

**In function FUN_ExHandler_00401070  (we get here because of division by zero, when we are not debugging)**
Links related to measure: 
- https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setunhandledexceptionfilter 
-  http://win32easy.blogspot.com/2011/03/exception-handling-inform-your-users.html 

What is being done in the exception handler: 

- It seems that another exception handler is registered. So next exception will probably trigger a different exception handler. 
    - not 100% sure to what address the new exception handler has. One guess was that the as a parameter the address of the cause (address of division by zero) is passed as parameter and to that address some offset is added. 
        - "0x004011f6"  plus and offset "0xb0"  ( 4198902 plus
 176 = 4199078 => "004012A6")
        - so assuming that another exception occurs (from looking at the code this will happen because we either jump to an invalid instructions or have maybe another division by zero)
- Return value is 0xffffffff which means that we continue where the exception has occured. (according to links)

<span style="color:red">I believe I missed some Instruction Weaving here or in the code execution that that runs next. </span>


**Hypothetical guess: Continuing at address 0x004012A6 (decimal: 04199078)**
Assuming we continue execution at memory address "004012A6" (changes exception handler and another ex triggered), code is exiting and but will register a function that runs on exit. 

However, I don't think this is actually what is happening because a) I followed all the execution flows and don't see anything meaningful happening and b) I belive the i missed some Instruction Weaving

```
004012A6    FNCLEX   ; clears exception 
004012a8    CALL FUN_004019f7   (FUN_CONTEX_One_004019f7)

004012ad    PUSH LAB_00401a23  ; cleanup function registered (renamed LAB_00401a23_Cleanup)
            CALL_atexit
            CALL FUN_004017b3  ; will just return one (FUN_Return_1_004017b3)

```




## Simple refreshers and links

*Remark: a bit random*

x86 64 bit assembler 
- https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf 

- https://www.nasm.us/ NASM
- https://filippo.io/linux-syscall-table/ (System calls on linux)
- https://en.wikipedia.org/wiki/X86_instruction_listings instructions
- https://www.felixcloutier.com/x86/ (also instructions)
- https://faydoc.tripod.com/cpu/jc.htm  (instructions...good for jump instructions)


Good to know
- `LEA EDI, [ESI+0xffffa000]=>DAT_00401000`  "=>" means that Ghidra was able to infer that [ESI+0xffffa000] is the value of memory address DAT_004010000


Examples instructions
- `MOV dst src` -> moves data from source to destiation
    - src can be pointers to memory, registers, constants
    - dst can be pointers to memory + registers (some registers are excluded)
- `LEA rsi [someLabel]` -> moves/loads the memory address into rsi   

- Size (for constant declaratiosn)
    - "db": byte ->  one-byte integer
    - "dw"  WORD ->  two-byte integer (16bit)
    - "dd"  DOUBLEWORD (DWORD) -> four-byte integer (32bit)
    - "dq" -> QUADWORD (QWORD) -> eight-byte integer (64bit)
        - The size of a register (e.g. "RDI")
- Values in memory are in little endian format. 
    - Example hex number: 4F52 
        - little endian:  52 4F
            - 52 at addresse 1000, 4f at address 1001
            - used by x86 CPU's
        - big endian (intuitive):  4F 52


*Remark: Theoretically the size of a word could depend on the unit the processor could process in one step or in some cases (programming languages) on the context. * 

