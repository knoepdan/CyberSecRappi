# Analyze exe with Ghidra1E

Generall info: 
- 32 bit application for windows
- Calling conventions used
    -  "cdecl" (which seems to be used.. but maybe not for all calls)
        - All params on stack
        - Return value usually in EAX (exception: floating point.. see wiki)
        - EAX, ECX und EDX can be used freely in function (other register need to be saved on stack)
    - stdcall (standard for WIN32-API functions)
        - return value in EAX
        - (stack handling slightly different)
    - See : https://de.wikipedia.org/wiki/Aufrufkonvention

## Steps

### Unpack using UPX (on Kali Linux)
https://manalyzer.org  indicated file was packed so I unpacked it using upx. 

`upx --best -d sample2.exe` will unpack the file sample2.exe and replace it

(not using unipacker because installation was cumbersome due to some pyhton version issues)

### Analyze and disassemble

*Debugging not possible due to linking error (anti debugging measures could be patched*)

**Following jumps** (and what is the state in registers / memory address)


**FUN_Main_004011b0**

"Empty return" detected. We will be forwarded (return) to "004011d5" (004011be + 0x17) 
```
004011b9   CALL LAB_004011be  ; will never be 0 
004011be   ADD byte ptr [ESP], 0x17 ; will set the stackpoint to an address which is 004011be + 0x17 (because CALL instruction pushes ) 
...  .. will execute a CALL and then correct the stackpointer ESP for the arguments being used (ADD ESP, 0x4)
RET ;   will return to 004011d5   (004011be + 0x17)

```

**From address 004011d5 (undefined func, 004011be + 0x17) -> jump to LAB_004011e9_NoDebuggerAttaqched**
Anti-debugging measure detected. If debugger is attached, we exit otherwise we jump to a label
```
004011d5   CALL IsDebuggerPresent  ; false (0) if no debugger is present, true (any value != 0) if there is a debugger -> written to EAX
004011db   TEST EAX, EAX   ; sets ZF flag to 1 if value is 0 (NO Debugger attached)
004011dd   JZ, LAB_004011e9   ; jumpf if ZF=1  (will only jump if NO debugger is present !!!)
```

**From LAB_004011e9_NoDebuggerAttached (exception handler function)**

Anti-debugging measure detected. We register a exception handler function and then an exception is triggered by a devision by zero.
```
0040126f   CALL ... ; register FUN_00401070 as handler for exceptions     
004011f4   XOR  EAX, EAX ; -> will fill EAX with 0
004011f6   DIV EAX;    will cause an exception (division by zero) and the previously registered function is executed
```

**In function FUN_ExHandler_00401070  (we get here because of division by zero, when we are not debugging)**
Links related to measure: 
- https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setunhandledexceptionfilter 
-  http://win32easy.blogspot.com/2011/03/exception-handling-inform-your-users.html 

Another exception handler is registered! It seems its the address where the exception occured "0x004011f6"  plus and offset "0xb0"  ( 4198902
+ 176 = 4199078 => "004012A6")

Return value is 0xffffffff which means that we continue where the exception has occured. (according to links)

-> we will continue execution where exception has occured (because of return value 0xffffffff).


*probably makes no sense*
```
00401091   OR  EAX, 0xffffffff  ;   sets return value. 
...
00401095   RET 0x4  ; return stdcall convention (0xffffffff means we continue execution where original exception has occured)
```

**Continuing at address 0x004012A6 (decimal: 04199078)**
```
004012A6    FNCLEX   ; clears exception 
004012a8    CALL FUN_004019f7   (FUN_CONTEX_One_004019f7)

004012ad    PUSH LAB_00401a23  ; cleanup function registered (renamed LAB_00401a23_Cleanup)
            CALL_atexit
            CALL FUN_004017b3  ; will just return one (FUN_Return_1_004017b3)

```


**FUN_004019f7**









## Leftovers

x86 64 bit assembler 
- https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf 

- https://www.nasm.us/ NASM
- https://filippo.io/linux-syscall-table/ (System calls on linux)
- https://en.wikipedia.org/wiki/X86_instruction_listings instructions
- https://www.felixcloutier.com/x86/ (also instructions)
- https://faydoc.tripod.com/cpu/jc.htm  (instructions...good for jump instructions)


Good to know
- `LEA EDI, [ESI+0xffffa000]=>DAT_00401000`  "=>" means that Ghidra was able to infer that [ESI+0xffffa000] is the value of memory address DAT_004010000


Examples instructions
- `MOV dst src` -> moves data from source to destiation
    - src can be pointers to memory, registers, constants
    - dst can be pointers to memory + registers (some registers are excluded)
- `LEA rsi [someLabel]` -> moves/loads the memory address into rsi   

- Size (for constant declaratiosn)
    - "db": byte ->  one-byte integer
    - "dw"  WORD ->  two-byte integer (16bit)
    - "dd"  DOUBLEWORD (DWORD) -> four-byte integer (32bit)
    - "dq" -> QUADWORD (QWORD) -> eight-byte integer (64bit)
        - The size of a register (e.g. "RDI")
- Values in memory are in little endian format. 
    - Example hex number: 4F52 
        - little endian:  52 4F
            - 52 at addresse 1000, 4f at address 1001
            - used by x86 CPU's
        - big endian (intuitive):  4F 52


*Remark: Theoretically the size of a word could depend on the unit the processor could process in one step or in some cases (programming languages) on the context. * 

