# Analyze exe with Ghidra1E


## Unpack using UPX (on Kali Linux)
https://manalyzer.org  indicated file was packed so I unpacked it using upx. 

`upx --best -d sample2.exe` will unpack the file sample2.exe and replace it

(not using unipacker because installation was cumbersome due to some pyhton version issues)

## Analyze

**Following jumps** (and what is the state in registers / memory address)


-------------
**FUN_MaybeMain_004011b0**

```
004011c2   TEST ESP, ESP  ; will never be 0 
004011c4   JNZ  LAB_004011c6  ; will always jump
```
-> makes no sense to have a JNZ instruction but the jump location is the next isntruction there is no need to patch this



```
004011b9   CALL LAB_004011be  ; will never be 0 
004011be   ADD byte ptr [ESP], 0x17 ; will set the stackpoint to an address which is 004011be + 0x17 (because CALL instruction pushes ) 
...  .. will execute a CALL and then correct the stackpointer ESP for the arguments being used (ADD ESP, 0x4)
RET ;   will return to 004011d5   (004011be + 0x17)

```
-> 


## Leftovers

x86 64 bit assembler 
- https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf 

- https://www.nasm.us/ NASM
- https://filippo.io/linux-syscall-table/ (System calls on linux)
- https://en.wikipedia.org/wiki/X86_instruction_listings instructions
- https://www.felixcloutier.com/x86/ (also instructions)
- https://faydoc.tripod.com/cpu/jc.htm  (instructions...good for jump instructions)


Good to know
- `LEA EDI, [ESI+0xffffa000]=>DAT_00401000`  "=>" means that Ghidra was able to infer that [ESI+0xffffa000] is the value of memory address DAT_004010000


Examples instructions
- `MOV dst src` -> moves data from source to destiation
    - src can be pointers to memory, registers, constants
    - dst can be pointers to memory + registers (some registers are excluded)
- `LEA rsi [someLabel]` -> moves/loads the memory address into rsi   

- Size (for constant declaratiosn)
    - "db": byte ->  one-byte integer
    - "dw"  WORD ->  two-byte integer (16bit)
    - "dd"  DOUBLEWORD (DWORD) -> four-byte integer (32bit)
    - "dq" -> QUADWORD (QWORD) -> eight-byte integer (64bit)
        - The size of a register (e.g. "RDI")
- Values in memory are in little endian format. 
    - Example hex number: 4F52 
        - little endian:  52 4F
            - 52 at addresse 1000, 4f at address 1001
            - used by x86 CPU's
        - big endian (intuitive):  4F 52


*Remark: Theoretically the size of a word could depend on the unit the processor could process in one step or in some cases (programming languages) on the context. * 

