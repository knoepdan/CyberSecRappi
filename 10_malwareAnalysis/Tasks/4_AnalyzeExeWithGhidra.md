# Analyze exe with Ghidra1E

```
1. PUSHAD - > will push all 32 registers onto the stack
2. MOV ESI, DAT_00407000   -> moves value at that memory address to ESI
3. LEA  EDI, [ESI + 0xffffa000] => DAT_00401000
4. PUSH EDI=>DAT_00401000
5. OR  EBP, 0xffffffff  -> 
6. JMP 

```


1. entry
    State: 
        - top on Stack: DAT_00401000  (address)
        - EDI: DAT_00401000  (address)
        - EBP: 0xffffffff 
        - ESI: DAT_00407000

2. LAB_00407fd2   ()
    - EBX: FE49FFF6h   (value from DAT_00407000)
    - ESI: -> -> goes lower than 00401000 -4: "00400ffc"
    - Carry flag set?  -> check ADC EBX,EBX (FE49FFF6h)   -> will be set to 1

4. LAB_00407fc8
    - AL: b8   (8bit reg of AX, EAX, RAX)
    - ESI:   00400ffd  "00400ffc incremented by one"
    - DAT_004010000 > value at address set to "b8"
    - EDI: DAT_00401000 + 1

## Leftovers

x86 64 bit assembler 
- https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf 

- https://www.nasm.us/ NASM
- https://filippo.io/linux-syscall-table/ (System calls on linux)
- https://en.wikipedia.org/wiki/X86_instruction_listings instructions
- https://www.felixcloutier.com/x86/ (also instructions)
- https://faydoc.tripod.com/cpu/jc.htm  (instructions...good for jump instructions)


Good to know
- `LEA EDI, [ESI+0xffffa000]=>DAT_00401000`  "=>" means that Ghidra was able to infer that [ESI+0xffffa000] is the value of memory address DAT_004010000


Examples instructions
- `MOV dst src` -> moves data from source to destiation
    - src can be pointers to memory, registers, constants
    - dst can be pointers to memory + registers (some registers are excluded)
- `LEA rsi [someLabel]` -> moves/loads the memory address into rsi   

- Size (for constant declaratiosn)
    - "db": byte ->  one-byte integer
    - "dw"  WORD ->  two-byte integer (16bit)
    - "dd"  DOUBLEWORD (DWORD) -> four-byte integer (32bit)
    - "dq" -> QUADWORD (QWORD) -> eight-byte integer (64bit)
        - The size of a register (e.g. "RDI")
- Values in memory are in little endian format. 
    - Example hex number: 4F52 
        - little endian:  52 4F
            - 52 at addresse 1000, 4f at address 1001
            - used by x86 CPU's
        - big endian (intuitive):  4F 52


*Remark: Theoretically the size of a word could depend on the unit the processor could process in one step or in some cases (programming languages) on the context. * 

